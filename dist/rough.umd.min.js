(function(e,t){'object'==typeof exports&&'undefined'!=typeof module?module.exports=t():'function'==typeof define&&define.amd?define(t):e.rough=t()})(this,function(){'use strict';function e(e,t){return e.type===t}function t(e,t){let i=t.fillStyle||'hachure';if(!v[i])switch(i){case'zigzag':v[i]||(v[i]=new O(e));break;case'cross-hatch':v[i]||(v[i]=new P(e));break;case'hachure':default:i='hachure',v[i]||(v[i]=new m(e));}return v[i]}var i=Math.round,s=Math.tan,n=Math.max,l=Math.min,o=Number.MAX_VALUE,a=Math.pow,p=Math.floor,r=Math.sqrt,d=Math.cos,f=Math.sin,h=Math.abs,g=Math.PI;const c={A:{length:7},a:{length:7},C:{length:6},c:{length:6},H:{length:1},h:{length:1},L:{length:2},l:{length:2},M:{length:2},m:{length:2},Q:{length:4},q:{length:4},S:{length:4},s:{length:4},T:{length:4},t:{length:2},V:{length:1},v:{length:1},Z:{length:0},z:{length:0}};class u{constructor(e){this.COMMAND=0,this.NUMBER=1,this.EOD=2,this.segments=[],this.parseData(e),this.processPoints()}tokenize(e){const t=[];for(;''!==e;)if(e.match(/^([ \t\r\n,]+)/))e=e.substr(RegExp.$1.length);else if(e.match(/^([aAcChHlLmMqQsStTvVzZ])/))t[t.length]={type:this.COMMAND,text:RegExp.$1},e=e.substr(RegExp.$1.length);else if(e.match(/^(([-+]?[0-9]+(\.[0-9]*)?|[-+]?\.[0-9]+)([eE][-+]?[0-9]+)?)/))t[t.length]={type:this.NUMBER,text:`${parseFloat(RegExp.$1)}`},e=e.substr(RegExp.$1.length);else return console.error('Unrecognized segment command: '+e),[];return t[t.length]={type:this.EOD,text:''},t}parseData(t){const s=this.tokenize(t);let n=0,i=s[n],a='BOD';for(this.segments=[];!e(i,this.EOD);){let l;const o=[];if(!('BOD'===a))e(i,this.NUMBER)?l=c[a].length:(n++,l=c[i.text].length,a=i.text);else if('M'===i.text||'m'===i.text)n++,l=c[i.text].length,a=i.text;else return void this.parseData('M0,0'+t);if(n+l<s.length){for(let t=n;t<n+l;t++){const i=s[t];if(e(i,this.NUMBER))o[o.length]=+i.text;else return void console.error('Parameter type is not a number: '+a+','+i.text)}if(c[a]){const e={key:a,data:o};this.segments.push(e),n+=l,i=s[n],'M'===a&&(a='L'),'m'===a&&(a='l')}else return void console.error('Unsupported segment type: '+a)}else console.error('Path data ended before all parameters were found')}}get closed(){if('undefined'==typeof this._closed){this._closed=!1;for(const e of this.segments)'z'===e.key.toLowerCase()&&(this._closed=!0)}return this._closed}processPoints(){let e=null,t=[0,0];for(let n=0;n<this.segments.length;n++){const i=this.segments[n];switch(i.key){case'M':case'L':case'T':i.point=[i.data[0],i.data[1]];break;case'm':case'l':case't':i.point=[i.data[0]+t[0],i.data[1]+t[1]];break;case'H':i.point=[i.data[0],t[1]];break;case'h':i.point=[i.data[0]+t[0],t[1]];break;case'V':i.point=[t[0],i.data[0]];break;case'v':i.point=[t[0],i.data[0]+t[1]];break;case'z':case'Z':e&&(i.point=[e[0],e[1]]);break;case'C':i.point=[i.data[4],i.data[5]];break;case'c':i.point=[i.data[4]+t[0],i.data[5]+t[1]];break;case'S':i.point=[i.data[2],i.data[3]];break;case's':i.point=[i.data[2]+t[0],i.data[3]+t[1]];break;case'Q':i.point=[i.data[2],i.data[3]];break;case'q':i.point=[i.data[2]+t[0],i.data[3]+t[1]];break;case'A':i.point=[i.data[5],i.data[6]];break;case'a':i.point=[i.data[5]+t[0],i.data[6]+t[1]];}('m'===i.key||'M'===i.key)&&(e=null),i.point&&(t=i.point,!e&&(e=i.point)),('z'===i.key||'Z'===i.key)&&(e=null)}}}class y{constructor(e){this._position=[0,0],this._first=null,this.bezierReflectionPoint=null,this.quadReflectionPoint=null,this.parsed=new u(e)}get segments(){return this.parsed.segments}get closed(){return this.parsed.closed}get linearPoints(){if(!this._linearPoints){const e=[];let t=[];for(const i of this.parsed.segments){const s=i.key.toLowerCase();('m'===s||'z'===s)&&(t.length&&(e.push(t),t=[]),'z'===s)||i.point&&t.push(i.point)}t.length&&(e.push(t),t=[]),this._linearPoints=e}return this._linearPoints}get first(){return this._first}set first(e){this._first=e}setPosition(e,t){this._position=[e,t],this._first||(this._first=[e,t])}get position(){return this._position}get x(){return this._position[0]}get y(){return this._position[1]}}class _{constructor(e,t,i,s,n,a){if(this._segIndex=0,this._numSegs=0,this._rx=0,this._ry=0,this._sinPhi=0,this._cosPhi=0,this._C=[0,0],this._theta=0,this._delta=0,this._T=0,this._from=e,e[0]===t[0]&&e[1]===t[1])return;const l=g/180;this._rx=h(i[0]),this._ry=h(i[1]),this._sinPhi=f(s*l),this._cosPhi=d(s*l);const o=this._cosPhi*(e[0]-t[0])/2+this._sinPhi*(e[1]-t[1])/2,p=-this._sinPhi*(e[0]-t[0])/2+this._cosPhi*(e[1]-t[1])/2;let c=0;const u=this._rx*this._rx*this._ry*this._ry-this._rx*this._rx*p*p-this._ry*this._ry*o*o;if(0>u){const e=r(1-u/(this._rx*this._rx*this._ry*this._ry));this._rx*=e,this._ry*=e,c=0}else c=(n===a?-1:1)*r(u/(this._rx*this._rx*p*p+this._ry*this._ry*o*o));const y=c*this._rx*p/this._ry,_=-c*this._ry*o/this._rx;this._C=[0,0],this._C[0]=this._cosPhi*y-this._sinPhi*_+(e[0]+t[0])/2,this._C[1]=this._sinPhi*y+this._cosPhi*_+(e[1]+t[1])/2,this._theta=this.calculateVectorAngle(1,0,(o-y)/this._rx,(p-_)/this._ry);let x=this.calculateVectorAngle((o-y)/this._rx,(p-_)/this._ry,(-o-y)/this._rx,(-p-_)/this._ry);!a&&0<x?x-=2*g:a&&0>x&&(x+=2*g),this._numSegs=Math.ceil(h(x/(g/2))),this._delta=x/this._numSegs,this._T=8/3*f(this._delta/4)*f(this._delta/4)/f(this._delta/2)}getNextSegment(){if(this._segIndex===this._numSegs)return null;const e=d(this._theta),t=f(this._theta),i=this._theta+this._delta,s=d(i),n=f(i),a=[this._cosPhi*this._rx*s-this._sinPhi*this._ry*n+this._C[0],this._sinPhi*this._rx*s+this._cosPhi*this._ry*n+this._C[1]],l=[this._from[0]+this._T*(-this._cosPhi*this._rx*t-this._sinPhi*this._ry*e),this._from[1]+this._T*(-this._sinPhi*this._rx*t+this._cosPhi*this._ry*e)],o=[a[0]+this._T*(this._cosPhi*this._rx*n+this._sinPhi*this._ry*s),a[1]+this._T*(this._sinPhi*this._rx*n-this._cosPhi*this._ry*s)];return this._theta=i,this._from=[a[0],a[1]],this._segIndex++,{cp1:l,cp2:o,to:a}}calculateVectorAngle(e,t,i,s){var n=Math.atan2;const a=n(t,e),l=n(s,i);return l>=a?l-a:2*g-(a-l)}}class x{constructor(e,t){this.sets=e,this.closed=t}fit(e){const t=[];for(const i of this.sets){const s=i.length;let n=p(e*s);if(5>n){if(5>=s)continue;n=5}t.push(this.reduce(i,n))}let s='';for(const n of t){for(let e=0;e<n.length;e++){const t=n[e];s+=0===e?'M'+t[0]+','+t[1]:'L'+t[0]+','+t[1]}this.closed&&(s+='z ')}return s}distance(e,t){return r(a(e[0]-t[0],2)+a(e[1]-t[1],2))}reduce(e,t){if(e.length<=t)return e;const n=e.slice(0);for(;n.length>t;){let e=-1,t=-1;for(let l=1;l<n.length-1;l++){const i=this.distance(n[l-1],n[l]),a=this.distance(n[l],n[l+1]),o=this.distance(n[l-1],n[l+1]),p=(i+a+o)/2,s=r(p*(p-i)*(p-a)*(p-o));(0>e||s<e)&&(e=s,t=l)}if(0<t)n.splice(t,1);else break}return n}}class b{constructor(e,t){this.xi=o,this.yi=o,this.px1=e[0],this.py1=e[1],this.px2=t[0],this.py2=t[1],this.a=this.py2-this.py1,this.b=this.px1-this.px2,this.c=this.px2*this.py1-this.px1*this.py2,this._undefined=0===this.a&&0===this.b&&0===this.c}isUndefined(){return this._undefined}intersects(e){if(this.isUndefined()||e.isUndefined())return!1;let t=o,i=o,s=0,p=0;const r=this.a,a=this.b,d=this.c;return(1e-5<h(a)&&(t=-r/a,s=-d/a),1e-5<h(e.b)&&(i=-e.a/e.b,p=-e.c/e.b),t===o)?i===o?-d/r==-e.c/e.a&&(this.py1>=l(e.py1,e.py2)&&this.py1<=n(e.py1,e.py2)?(this.xi=this.px1,this.yi=this.py1,!0):!!(this.py2>=l(e.py1,e.py2)&&this.py2<=n(e.py1,e.py2))&&(this.xi=this.px2,this.yi=this.py2,!0)):(this.xi=this.px1,this.yi=i*this.xi+p,!(-1e-5>(this.py1-this.yi)*(this.yi-this.py2)||-1e-5>(e.py1-this.yi)*(this.yi-e.py2))&&(!(1e-5>h(e.a))||!(-1e-5>(e.px1-this.xi)*(this.xi-e.px2)))):i===o?(this.xi=e.px1,this.yi=t*this.xi+s,!(-1e-5>(e.py1-this.yi)*(this.yi-e.py2)||-1e-5>(this.py1-this.yi)*(this.yi-this.py2))&&(!(1e-5>h(r))||!(-1e-5>(this.px1-this.xi)*(this.xi-this.px2)))):t===i?s==p&&(this.px1>=l(e.px1,e.px2)&&this.px1<=n(e.py1,e.py2)?(this.xi=this.px1,this.yi=this.py1,!0):!!(this.px2>=l(e.px1,e.px2)&&this.px2<=n(e.px1,e.px2))&&(this.xi=this.px2,this.yi=this.py2,!0)):(this.xi=(p-s)/(t-i),this.yi=t*this.xi+s,!(-1e-5>(this.px1-this.xi)*(this.xi-this.px2)||-1e-5>(e.px1-this.xi)*(this.xi-e.px2)))}}class w{constructor(e,t,i,s,n,a,l,o){this.deltaX=0,this.hGap=0,this.top=e,this.bottom=t,this.left=i,this.right=s,this.gap=n,this.sinAngle=a,this.tanAngle=o,1e-4>h(a)?this.pos=i+n:.9999<h(a)?this.pos=e+n:(this.deltaX=(t-e)*h(o),this.pos=i-h(this.deltaX),this.hGap=h(n/l),this.sLeft=new b([i,t],[i,e]),this.sRight=new b([s,t],[s,e]))}nextLine(){if(1e-4>h(this.sinAngle)){if(this.pos<this.right){const e=[this.pos,this.top,this.pos,this.bottom];return this.pos+=this.gap,e}}else if(!(.9999<h(this.sinAngle))){let e=this.pos-this.deltaX/2,t=this.pos+this.deltaX/2,i=this.bottom,n=this.top;if(this.pos<this.right+this.deltaX){for(;e<this.left&&t<this.left||e>this.right&&t>this.right;)if(this.pos+=this.hGap,e=this.pos-this.deltaX/2,t=this.pos+this.deltaX/2,this.pos>this.right+this.deltaX)return null;const a=new b([e,i],[t,n]);this.sLeft&&a.intersects(this.sLeft)&&(e=a.xi,i=a.yi),this.sRight&&a.intersects(this.sRight)&&(t=a.xi,n=a.yi),0<this.tanAngle&&(e=this.right-(e-this.left),t=this.right-(t-this.left));const s=[e,i,t,n];return this.pos+=this.hGap,s}}else if(this.pos<this.bottom){const e=[this.left,this.pos,this.right,this.pos];return this.pos+=this.gap,e}return null}}class m{constructor(e){this.renderer=e}fillPolygon(e,t){return this._fillPolygon(e,t)}fillEllipse(e,t,i,s,n){return this._fillEllipse(e,t,i,s,n)}_fillPolygon(e,t,a=!1){let o=[];if(e&&e.length){let p=e[0][0],r=e[0][0],h=e[0][1],c=e[0][1];for(let t=1;t<e.length;t++)p=l(p,e[t][0]),r=n(r,e[t][0]),h=l(h,e[t][1]),c=n(c,e[t][1]);const i=t.hachureAngle;let u=t.hachureGap;0>u&&(u=4*t.strokeWidth),u=n(u,.1);const y=i%180*(g/180),_=d(y),x=f(y),b=s(y),m=new w(h-1,c+1,p-1,r+1,u,x,_,b);for(let i,s=null;null!=(i=m.nextLine());){const n=this.getIntersectingLines(i,e);for(let e=0;e<n.length;e++)if(e<n.length-1){const i=n[e],l=n[e+1];o=o.concat(this.renderer.doubleLine(i[0],i[1],l[0],l[1],t)),a&&s&&(o=o.concat(this.renderer.doubleLine(s[0],s[1],i[0],i[1],t))),s=l}}}return{type:'fillSketch',ops:o}}_fillEllipse(e,t,i,n,a,l=!1){let o=[],p=h(i/2),d=h(n/2);p+=this.renderer.getOffset(.05*-p,.05*p,a),d+=this.renderer.getOffset(.05*-d,.05*d,a);const f=a.hachureAngle;let c=a.hachureGap;0>=c&&(c=4*a.strokeWidth);let u=a.fillWeight;0>u&&(u=a.strokeWidth/2);const y=s(f%180*(g/180)),_=d/p,x=r(_*y*_*y+1),b=_*y/x,w=1/x,m=c/(p*d/r(d*w*(d*w)+p*b*(p*b))/p);let O=r(p*p-(e-p+m)*(e-p+m)),P=null;for(let s=e-p+m;s<e+p;s+=m){O=r(p*p-(e-s)*(e-s));const i=this.affine(s,t-O,e,t,b,w,_),n=this.affine(s,t+O,e,t,b,w,_);o=o.concat(this.renderer.doubleLine(i[0],i[1],n[0],n[1],a)),l&&P&&(o=o.concat(this.renderer.doubleLine(P[0],P[1],i[0],i[1],a))),P=n}return{type:'fillSketch',ops:o}}getIntersectingLines(e,t){const s=[],n=new b([e[0],e[1]],[e[2],e[3]]);for(let a=0;a<t.length;a++){const e=new b(t[a],t[(a+1)%t.length]);n.intersects(e)&&s.push([n.xi,n.yi])}return s}affine(e,t,i,s,n,a,l){return[-i*a-s*n+i+a*e+n*t,l*(i*n-s*a)+s+-l*n*e+l*a*t]}}class O extends m{fillPolygon(e,t){return this._fillPolygon(e,t,!0)}fillEllipse(e,t,i,s,n){return this._fillEllipse(e,t,i,s,n,!0)}}class P extends m{fillPolygon(e,t){const i=this._fillPolygon(e,t),s=Object.assign({},t,{hachureAngle:t.hachureAngle+90}),n=this._fillPolygon(e,s);return i.ops=i.ops.concat(n.ops),i}fillEllipse(e,t,i,s,n){const a=this._fillEllipse(e,t,i,s,n),l=Object.assign({},n,{hachureAngle:n.hachureAngle+90}),o=this._fillEllipse(e,t,i,s,l);return a.ops=a.ops.concat(o.ops),a}}const v={};class k{line(e,t,i,s,n){const a=this.doubleLine(e,t,i,s,n);return{type:'path',ops:a}}linearPath(e,t,s){const n=(e||[]).length;if(2<n){let a=[];for(let t=0;t<n-1;t++)a=a.concat(this.doubleLine(e[t][0],e[t][1],e[t+1][0],e[t+1][1],s));return t&&(a=a.concat(this.doubleLine(e[n-1][0],e[n-1][1],e[0][0],e[0][1],s))),{type:'path',ops:a}}return 2===n?this.line(e[0][0],e[0][1],e[1][0],e[1][1],s):{type:'path',ops:[]}}polygon(e,t){return this.linearPath(e,!0,t)}rectangle(e,t,i,s,n){return this.polygon([[e,t],[e+i,t],[e+i,t+s],[e,t+s]],n)}curve(e,t){const i=this._curveWithOffset(e,1*(1+.2*t.roughness),t),s=this._curveWithOffset(e,1.5*(1+.22*t.roughness),t);return{type:'path',ops:i.concat(s)}}ellipse(e,t,i,s,n){const a=2*g/n.curveStepCount;let l=h(i/2),o=h(s/2);l+=this.getOffset(.05*-l,.05*l,n),o+=this.getOffset(.05*-o,.05*o,n);const p=this._ellipse(a,e,t,l,o,1,a*this.getOffset(.1,this.getOffset(.4,1,n),n),n),r=this._ellipse(a,e,t,l,o,1.5,0,n);return{type:'path',ops:p.concat(r)}}arc(e,t,i,s,n,a,p,r,c){const o=e,u=t;let y=h(i/2),_=h(s/2);y+=this.getOffset(.01*-y,.01*y,c),_+=this.getOffset(.01*-_,.01*_,c);let x=n,b=a;for(;0>x;)x+=2*g,b+=2*g;b-x>2*g&&(x=0,b=2*g);const w=2*g/c.curveStepCount,m=l(w/2,(b-x)/2),O=this._arc(m,o,u,y,_,x,b,1,c),P=this._arc(m,o,u,y,_,x,b,1.5,c);let v=O.concat(P);return p&&(r?(v=v.concat(this.doubleLine(o,u,o+y*d(x),u+_*f(x),c)),v=v.concat(this.doubleLine(o,u,o+y*d(b),u+_*f(b),c))):(v.push({op:'lineTo',data:[o,u]}),v.push({op:'lineTo',data:[o+y*d(x),u+_*f(x)]}))),{type:'path',ops:v}}svgPath(e,t){e=(e||'').replace(/\n/g,' ').replace(/(-\s)/g,'-').replace('/(ss)/g',' ');let n=new y(e);if(t.simplification){const e=new x(n.linearPoints,n.closed),i=e.fit(t.simplification);n=new y(i)}let a=[];const l=n.segments||[];for(let o=0;o<l.length;o++){const e=l[o],i=0<o?l[o-1]:null,s=this._processSegment(n,e,i,t);s&&s.length&&(a=a.concat(s))}return{type:'path',ops:a}}solidFillPolygon(e,t){const s=[];if(PointerEvent.length){const n=t.maxRandomnessOffset||0,a=e.length;if(2<a){s.push({op:'move',data:[e[0][0]+this.getOffset(-n,n,t),e[0][1]+this.getOffset(-n,n,t)]});for(let l=1;l<a;l++)s.push({op:'lineTo',data:[e[l][0]+this.getOffset(-n,n,t),e[l][1]+this.getOffset(-n,n,t)]})}}return{type:'fillPath',ops:s}}patternFillPolygon(e,i){const s=t(this,i);return s.fillPolygon(e,i)}patternFillEllipse(e,i,s,n,a){const l=t(this,a);return l.fillEllipse(e,i,s,n,a)}patternFillArc(e,t,i,s,n,a,l){const o=e,p=t;let r=h(i/2),c=h(s/2);r+=this.getOffset(.01*-r,.01*r,l),c+=this.getOffset(.01*-c,.01*c,l);let u=n,y=a;for(;0>u;)u+=2*g,y+=2*g;y-u>2*g&&(u=0,y=2*g);const _=(y-u)/l.curveStepCount,x=[];for(let h=u;h<=y;h+=_)x.push([o+r*d(h),p+c*f(h)]);return x.push([o+r*d(y),p+c*f(y)]),x.push([o,p]),this.patternFillPolygon(x,l)}getOffset(e,t,i){return i.roughness*(Math.random()*(t-e)+e)}doubleLine(e,t,i,s,n){const a=this._line(e,t,i,s,n,!0,!1),l=this._line(e,t,i,s,n,!0,!0);return a.concat(l)}_line(e,t,i,s,n,l,o){const p=a(e-i,2)+a(t-s,2);let d=n.maxRandomnessOffset||0;100*(d*d)>p&&(d=r(p)/10);const f=d/2,h=.2+.2*Math.random();let g=n.bowing*n.maxRandomnessOffset*(s-t)/200,c=n.bowing*n.maxRandomnessOffset*(e-i)/200;g=this.getOffset(-g,g,n),c=this.getOffset(-c,c,n);const u=[];return l&&(o?u.push({op:'move',data:[e+this.getOffset(-f,f,n),t+this.getOffset(-f,f,n)]}):u.push({op:'move',data:[e+this.getOffset(-d,d,n),t+this.getOffset(-d,d,n)]})),o?u.push({op:'bcurveTo',data:[g+e+(i-e)*h+this.getOffset(-f,f,n),c+t+(s-t)*h+this.getOffset(-f,f,n),g+e+2*(i-e)*h+this.getOffset(-f,f,n),c+t+2*(s-t)*h+this.getOffset(-f,f,n),i+this.getOffset(-f,f,n),s+this.getOffset(-f,f,n)]}):u.push({op:'bcurveTo',data:[g+e+(i-e)*h+this.getOffset(-d,d,n),c+t+(s-t)*h+this.getOffset(-d,d,n),g+e+2*(i-e)*h+this.getOffset(-d,d,n),c+t+2*(s-t)*h+this.getOffset(-d,d,n),i+this.getOffset(-d,d,n),s+this.getOffset(-d,d,n)]}),u}_curve(e,t,i){const n=e.length;let a=[];if(3<n){const l=[],o=1-i.curveTightness;a.push({op:'move',data:[e[1][0],e[1][1]]});for(let t=1;t+2<n;t++){const i=e[t];l[0]=[i[0],i[1]],l[1]=[i[0]+(o*e[t+1][0]-o*e[t-1][0])/6,i[1]+(o*e[t+1][1]-o*e[t-1][1])/6],l[2]=[e[t+1][0]+(o*e[t][0]-o*e[t+2][0])/6,e[t+1][1]+(o*e[t][1]-o*e[t+2][1])/6],l[3]=[e[t+1][0],e[t+1][1]],a.push({op:'bcurveTo',data:[l[1][0],l[1][1],l[2][0],l[2][1],l[3][0],l[3][1]]})}if(t&&2===t.length){const e=i.maxRandomnessOffset;a.push({op:'lineTo',data:[t[0]+this.getOffset(-e,e,i),t[1]+ +this.getOffset(-e,e,i)]})}}else 3===n?(a.push({op:'move',data:[e[1][0],e[1][1]]}),a.push({op:'bcurveTo',data:[e[1][0],e[1][1],e[2][0],e[2][1],e[2][0],e[2][1]]})):2===n&&(a=a.concat(this.doubleLine(e[0][0],e[0][1],e[1][0],e[1][1],i)));return a}_ellipse(e,t,i,s,n,a,l,p){const o=this.getOffset(-.5,.5,p)-g/2,r=[];r.push([this.getOffset(-a,a,p)+t+.9*s*d(o-e),this.getOffset(-a,a,p)+i+.9*n*f(o-e)]);for(let h=o;h<2*g+o-.01;h+=e)r.push([this.getOffset(-a,a,p)+t+s*d(h),this.getOffset(-a,a,p)+i+n*f(h)]);return r.push([this.getOffset(-a,a,p)+t+s*d(o+2*g+.5*l),this.getOffset(-a,a,p)+i+n*f(o+2*g+.5*l)]),r.push([this.getOffset(-a,a,p)+t+.98*s*d(o+l),this.getOffset(-a,a,p)+i+.98*n*f(o+l)]),r.push([this.getOffset(-a,a,p)+t+.9*s*d(o+.5*l),this.getOffset(-a,a,p)+i+.9*n*f(o+.5*l)]),this._curve(r,null,p)}_curveWithOffset(e,t,s){const n=[[e[0][0]+this.getOffset(-t,t,s),e[0][1]+this.getOffset(-t,t,s)],[e[0][0]+this.getOffset(-t,t,s),e[0][1]+this.getOffset(-t,t,s)]];for(let a=1;a<e.length;a++)n.push([e[a][0]+this.getOffset(-t,t,s),e[a][1]+this.getOffset(-t,t,s)]),a===e.length-1&&n.push([e[a][0]+this.getOffset(-t,t,s),e[a][1]+this.getOffset(-t,t,s)]);return this._curve(n,null,s)}_arc(e,t,i,s,n,a,l,p,r){const o=a+this.getOffset(-.1,.1,r),h=[];h.push([this.getOffset(-p,p,r)+t+.9*s*d(o-e),this.getOffset(-p,p,r)+i+.9*n*f(o-e)]);for(let g=o;g<=l;g+=e)h.push([this.getOffset(-p,p,r)+t+s*d(g),this.getOffset(-p,p,r)+i+n*f(g)]);return h.push([t+s*d(l),i+n*f(l)]),h.push([t+s*d(l),i+n*f(l)]),this._curve(h,null,r)}_bezierTo(e,t,s,n,a,l,p,r){const o=[],d=[r.maxRandomnessOffset||1,(r.maxRandomnessOffset||1)+.5];let h=[0,0];for(let f=0;2>f;f++)0===f?o.push({op:'move',data:[p.x,p.y]}):o.push({op:'move',data:[p.x+this.getOffset(-d[0],d[0],r),p.y+this.getOffset(-d[0],d[0],r)]}),h=[a+this.getOffset(-d[f],d[f],r),l+this.getOffset(-d[f],d[f],r)],o.push({op:'bcurveTo',data:[e+this.getOffset(-d[f],d[f],r),t+this.getOffset(-d[f],d[f],r),s+this.getOffset(-d[f],d[f],r),n+this.getOffset(-d[f],d[f],r),h[0],h[1]]});return p.setPosition(h[0],h[1]),o}_processSegment(e,t,i,s){let n=[];switch(t.key){case'M':case'm':{const i='m'===t.key;if(2<=t.data.length){let a=+t.data[0],l=+t.data[1];i&&(a+=e.x,l+=e.y);const o=1*(s.maxRandomnessOffset||0);a+=this.getOffset(-o,o,s),l+=this.getOffset(-o,o,s),e.setPosition(a,l),n.push({op:'move',data:[a,l]})}break}case'L':case'l':{const i='l'===t.key;if(2<=t.data.length){let a=+t.data[0],l=+t.data[1];i&&(a+=e.x,l+=e.y),n=n.concat(this.doubleLine(e.x,e.y,a,l,s)),e.setPosition(a,l)}break}case'H':case'h':{const i='h'===t.key;if(t.data.length){let a=+t.data[0];i&&(a+=e.x),n=n.concat(this.doubleLine(e.x,e.y,a,e.y,s)),e.setPosition(a,e.y)}break}case'V':case'v':{const i='v'===t.key;if(t.data.length){let a=+t.data[0];i&&(a+=e.y),n=n.concat(this.doubleLine(e.x,e.y,e.x,a,s)),e.setPosition(e.x,a)}break}case'Z':case'z':{e.first&&(n=n.concat(this.doubleLine(e.x,e.y,e.first[0],e.first[1],s)),e.setPosition(e.first[0],e.first[1]),e.first=null);break}case'C':case'c':{const i='c'===t.key;if(6<=t.data.length){let a=+t.data[0],l=+t.data[1],o=+t.data[2],p=+t.data[3],r=+t.data[4],d=+t.data[5];i&&(a+=e.x,o+=e.x,r+=e.x,l+=e.y,p+=e.y,d+=e.y);const f=this._bezierTo(a,l,o,p,r,d,e,s);n=n.concat(f),e.bezierReflectionPoint=[r+(r-o),d+(d-p)]}break}case'S':case's':{const a='s'===t.key;if(4<=t.data.length){let l=+t.data[0],o=+t.data[1],p=+t.data[2],r=+t.data[3];a&&(l+=e.x,p+=e.x,o+=e.y,r+=e.y);let d=l,f=o;const h=i?i.key:'';let g=null;('c'===h||'C'===h||'s'===h||'S'===h)&&(g=e.bezierReflectionPoint),g&&(d=g[0],f=g[1]);const c=this._bezierTo(d,f,l,o,p,r,e,s);n=n.concat(c),e.bezierReflectionPoint=[p+(p-l),r+(r-o)]}break}case'Q':case'q':{const i='q'===t.key;if(4<=t.data.length){let a=+t.data[0],l=+t.data[1],o=+t.data[2],p=+t.data[3];i&&(a+=e.x,o+=e.x,l+=e.y,p+=e.y);const r=1*(1+.2*s.roughness),d=1.5*(1+.22*s.roughness);n.push({op:'move',data:[e.x+this.getOffset(-r,r,s),e.y+this.getOffset(-r,r,s)]});let h=[o+this.getOffset(-r,r,s),p+this.getOffset(-r,r,s)];n.push({op:'qcurveTo',data:[a+this.getOffset(-r,r,s),l+this.getOffset(-r,r,s),h[0],h[1]]}),n.push({op:'move',data:[e.x+this.getOffset(-d,d,s),e.y+this.getOffset(-d,d,s)]}),h=[o+this.getOffset(-d,d,s),p+this.getOffset(-d,d,s)],n.push({op:'qcurveTo',data:[a+this.getOffset(-d,d,s),l+this.getOffset(-d,d,s),h[0],h[1]]}),e.setPosition(h[0],h[1]),e.quadReflectionPoint=[o+(o-a),p+(p-l)]}break}case'T':case't':{const a='t'===t.key;if(2<=t.data.length){let l=+t.data[0],o=+t.data[1];a&&(l+=e.x,o+=e.y);let p=l,r=o;const d=i?i.key:'';let h=null;('q'===d||'Q'===d||'t'===d||'T'===d)&&(h=e.quadReflectionPoint),h&&(p=h[0],r=h[1]);const g=1*(1+.2*s.roughness),c=1.5*(1+.22*s.roughness);n.push({op:'move',data:[e.x+this.getOffset(-g,g,s),e.y+this.getOffset(-g,g,s)]});let u=[l+this.getOffset(-g,g,s),o+this.getOffset(-g,g,s)];n.push({op:'qcurveTo',data:[p+this.getOffset(-g,g,s),r+this.getOffset(-g,g,s),u[0],u[1]]}),n.push({op:'move',data:[e.x+this.getOffset(-c,c,s),e.y+this.getOffset(-c,c,s)]}),u=[l+this.getOffset(-c,c,s),o+this.getOffset(-c,c,s)],n.push({op:'qcurveTo',data:[p+this.getOffset(-c,c,s),r+this.getOffset(-c,c,s),u[0],u[1]]}),e.setPosition(u[0],u[1]),e.quadReflectionPoint=[l+(l-p),o+(o-r)]}break}case'A':case'a':{const i='a'===t.key;if(7<=t.data.length){const a=+t.data[0],l=+t.data[1],o=+t.data[2],p=+t.data[3],r=+t.data[4];let d=+t.data[5],f=+t.data[6];if(i&&(d+=e.x,f+=e.y),d===e.x&&f===e.y)break;if(0==a||0==l)n=n.concat(this.doubleLine(e.x,e.y,d,f,s)),e.setPosition(d,f);else for(let t=0;1>t;t++){const t=new _([e.x,e.y],[d,f],[a,l],o,!!p,!!r);for(let i=t.getNextSegment();i;){const a=this._bezierTo(i.cp1[0],i.cp1[1],i.cp2[0],i.cp2[1],i.to[0],i.to[1],e,s);n=n.concat(a),i=t.getNextSegment()}}}break}default:}return n}}const A='undefined'!=typeof self;class S{constructor(e,t){this.defaultOptions={maxRandomnessOffset:2,roughness:1,bowing:1,stroke:'#000',strokeWidth:1,curveTightness:0,curveStepCount:9,fill:null,fillStyle:'hachure',fillWeight:-1,hachureAngle:-41,hachureGap:-1},this.config=e||{},this.surface=t,this.config.options&&(this.defaultOptions=this._options(this.config.options))}_options(e){return e?Object.assign({},this.defaultOptions,e):this.defaultOptions}_drawable(e,t,i){return{shape:e,sets:t||[],options:i||this.defaultOptions}}get lib(){return this.renderer||(this.renderer=new k),this.renderer}getCanvasSize(){const e=e=>e&&'object'==typeof e&&e.baseVal&&e.baseVal.value?e.baseVal.value:e||100;return this.surface?[e(this.surface.width),e(this.surface.height)]:[100,100]}computePathSize(e){let t=[0,0];if(A&&self.document)try{const i=self.document.createElementNS('http://www.w3.org/2000/svg','svg');i.setAttribute('width','0'),i.setAttribute('height','0');const s=self.document.createElementNS('http://www.w3.org/2000/svg','path');s.setAttribute('d',e),i.appendChild(s),self.document.body.appendChild(i);const n=s.getBBox();n&&(t[0]=n.width||0,t[1]=n.height||0),self.document.body.removeChild(i)}catch(e){}const i=this.getCanvasSize();return t[0]*t[1]||(t=i),t[0]=l(t[0],i[0]),t[1]=l(t[1],i[1]),t}line(e,t,i,s,n){const a=this._options(n);return this._drawable('line',[this.lib.line(e,t,i,s,a)],a)}rectangle(e,t,i,s,n){const a=this._options(n),l=[];if(a.fill){const n=[[e,t],[e+i,t],[e+i,t+s],[e,t+s]];'solid'===a.fillStyle?l.push(this.lib.solidFillPolygon(n,a)):l.push(this.lib.patternFillPolygon(n,a))}return l.push(this.lib.rectangle(e,t,i,s,a)),this._drawable('rectangle',l,a)}ellipse(e,t,i,s,n){const a=this._options(n),l=[];if(a.fill)if('solid'===a.fillStyle){const n=this.lib.ellipse(e,t,i,s,a);n.type='fillPath',l.push(n)}else l.push(this.lib.patternFillEllipse(e,t,i,s,a));return l.push(this.lib.ellipse(e,t,i,s,a)),this._drawable('ellipse',l,a)}circle(e,t,i,s){const n=this.ellipse(e,t,i,i,s);return n.shape='circle',n}linearPath(e,t){const i=this._options(t);return this._drawable('linearPath',[this.lib.linearPath(e,!1,i)],i)}polygon(e,t){const i=this._options(t),s=[];return i.fill&&('solid'===i.fillStyle?s.push(this.lib.solidFillPolygon(e,i)):s.push(this.lib.patternFillPolygon(e,i))),s.push(this.lib.linearPath(e,!0,i)),this._drawable('polygon',s,i)}arc(e,t,i,s,n,a,l=!1,p){const r=this._options(p),o=[];if(l&&r.fill)if('solid'===r.fillStyle){const l=this.lib.arc(e,t,i,s,n,a,!0,!1,r);l.type='fillPath',o.push(l)}else o.push(this.lib.patternFillArc(e,t,i,s,n,a,r));return o.push(this.lib.arc(e,t,i,s,n,a,l,!0,r)),this._drawable('arc',o,r)}curve(e,t){const i=this._options(t);return this._drawable('curve',[this.lib.curve(e,i)],i)}path(e,t){const i=this._options(t),s=[];if(!e)return this._drawable('path',s,i);if(i.fill)if('solid'===i.fillStyle){s.push({type:'path2Dfill',path:e,ops:[]})}else{const t=this.computePathSize(e),n=[[0,0],[t[0],0],[t[0],t[1]],[0,t[1]]],a=this.lib.patternFillPolygon(n,i);a.type='path2Dpattern',a.size=t,a.path=e,s.push(a)}return s.push(this.lib.svgPath(e,i)),this._drawable('path',s,i)}toPaths(e){const t=e.sets||[],s=e.options||this.defaultOptions,n=[];for(const a of t){let e=null;switch(a.type){case'path':e={d:this.opsToPath(a),stroke:s.stroke,strokeWidth:s.strokeWidth,fill:'none'};break;case'fillPath':e={d:this.opsToPath(a),stroke:'none',strokeWidth:0,fill:s.fill||'none'};break;case'fillSketch':e=this.fillSketch(a,s);break;case'path2Dfill':e={d:a.path||'',stroke:'none',strokeWidth:0,fill:s.fill||'none'};break;case'path2Dpattern':{const t=a.size,n={x:0,y:0,width:1,height:1,viewBox:`0 0 ${i(t[0])} ${i(t[1])}`,patternUnits:'objectBoundingBox',path:this.fillSketch(a,s)};e={d:a.path,stroke:'none',strokeWidth:0,pattern:n};break}}e&&n.push(e)}return n}fillSketch(e,t){let i=t.fillWeight;return 0>i&&(i=t.strokeWidth/2),{d:this.opsToPath(e),stroke:t.fill||'none',strokeWidth:i,fill:'none'}}opsToPath(e){let t='';for(const i of e.ops){const e=i.data;switch(i.op){case'move':t+=`M${e[0]} ${e[1]} `;break;case'bcurveTo':t+=`C${e[0]} ${e[1]}, ${e[2]} ${e[3]}, ${e[4]} ${e[5]} `;break;case'qcurveTo':t+=`Q${e[0]} ${e[1]}, ${e[2]} ${e[3]} `;break;case'lineTo':t+=`L${e[0]} ${e[1]} `;}}return t.trim()}}const T='undefined'!=typeof document;class C{constructor(e,t){this.canvas=e,this.ctx=this.canvas.getContext('2d'),this.gen=new S(t||null,this.canvas)}get generator(){return this.gen}static createRenderer(){return new k}line(e,t,i,s,n){const a=this.gen.line(e,t,i,s,n);return this.draw(a),a}rectangle(e,t,i,s,n){const a=this.gen.rectangle(e,t,i,s,n);return this.draw(a),a}ellipse(e,t,i,s,n){const a=this.gen.ellipse(e,t,i,s,n);return this.draw(a),a}circle(e,t,i,s){const n=this.gen.circle(e,t,i,s);return this.draw(n),n}linearPath(e,t){const i=this.gen.linearPath(e,t);return this.draw(i),i}polygon(e,t){const i=this.gen.polygon(e,t);return this.draw(i),i}arc(e,t,i,s,n,a,l=!1,o){const p=this.gen.arc(e,t,i,s,n,a,l,o);return this.draw(p),p}curve(e,t){const i=this.gen.curve(e,t);return this.draw(i),i}path(e,t){const i=this.gen.path(e,t);return this.draw(i),i}draw(e){const t=e.sets||[],i=e.options||this.gen.defaultOptions,s=this.ctx;for(const n of t)switch(n.type){case'path':s.save(),s.strokeStyle=i.stroke,s.lineWidth=i.strokeWidth,this._drawToContext(s,n),s.restore();break;case'fillPath':s.save(),s.fillStyle=i.fill||'',this._drawToContext(s,n),s.restore();break;case'fillSketch':this.fillSketch(s,n,i);break;case'path2Dfill':{this.ctx.save(),this.ctx.fillStyle=i.fill||'';const e=new Path2D(n.path);this.ctx.fill(e),this.ctx.restore();break}case'path2Dpattern':{if(T){const e=n.size,t=document.createElement('canvas'),s=t.getContext('2d'),a=this.computeBBox(n.path);a&&(a.width||a.height)?(t.width=this.canvas.width,t.height=this.canvas.height,s.translate(a.x||0,a.y||0)):(t.width=e[0],t.height=e[1]),this.fillSketch(s,n,i),this.ctx.save(),this.ctx.fillStyle=this.ctx.createPattern(t,'repeat');const l=new Path2D(n.path);this.ctx.fill(l),this.ctx.restore()}break}}}computeBBox(e){if(T)try{const t=document.createElementNS('http://www.w3.org/2000/svg','svg');t.setAttribute('width','0'),t.setAttribute('height','0');const i=self.document.createElementNS('http://www.w3.org/2000/svg','path');i.setAttribute('d',e),t.appendChild(i),document.body.appendChild(t);const s=i.getBBox();return document.body.removeChild(t),s}catch(e){}return null}fillSketch(e,t,i){let s=i.fillWeight;0>s&&(s=i.strokeWidth/2),e.save(),e.strokeStyle=i.fill||'',e.lineWidth=s,this._drawToContext(e,t),e.restore()}_drawToContext(e,t){e.beginPath();for(const i of t.ops){const t=i.data;switch(i.op){case'move':e.moveTo(t[0],t[1]);break;case'bcurveTo':e.bezierCurveTo(t[0],t[1],t[2],t[3],t[4],t[5]);break;case'qcurveTo':e.quadraticCurveTo(t[0],t[1],t[2],t[3]);break;case'lineTo':e.lineTo(t[0],t[1]);}}'fillPath'===t.type?e.fill():e.stroke()}}class E extends S{async line(e,t,i,s,n){const a=this._options(n);return this._drawable('line',[await this.lib.line(e,t,i,s,a)],a)}async rectangle(e,t,i,s,n){const a=this._options(n),l=[];if(a.fill){const n=[[e,t],[e+i,t],[e+i,t+s],[e,t+s]];'solid'===a.fillStyle?l.push((await this.lib.solidFillPolygon(n,a))):l.push((await this.lib.patternFillPolygon(n,a)))}return l.push((await this.lib.rectangle(e,t,i,s,a))),this._drawable('rectangle',l,a)}async ellipse(e,t,i,s,n){const a=this._options(n),l=[];if(a.fill)if('solid'===a.fillStyle){const n=await this.lib.ellipse(e,t,i,s,a);n.type='fillPath',l.push(n)}else l.push((await this.lib.patternFillEllipse(e,t,i,s,a)));return l.push((await this.lib.ellipse(e,t,i,s,a))),this._drawable('ellipse',l,a)}async circle(e,t,i,s){const n=await this.ellipse(e,t,i,i,s);return n.shape='circle',n}async linearPath(e,t){const i=this._options(t);return this._drawable('linearPath',[await this.lib.linearPath(e,!1,i)],i)}async polygon(e,t){const i=this._options(t),s=[];return i.fill&&('solid'===i.fillStyle?s.push((await this.lib.solidFillPolygon(e,i))):s.push((await this.lib.patternFillPolygon(e,i)))),s.push((await this.lib.linearPath(e,!0,i))),this._drawable('polygon',s,i)}async arc(e,t,i,s,n,a,l=!1,p){const r=this._options(p),o=[];if(l&&r.fill)if('solid'===r.fillStyle){const l=await this.lib.arc(e,t,i,s,n,a,!0,!1,r);l.type='fillPath',o.push(l)}else o.push((await this.lib.patternFillArc(e,t,i,s,n,a,r)));return o.push((await this.lib.arc(e,t,i,s,n,a,l,!0,r))),this._drawable('arc',o,r)}async curve(e,t){const i=this._options(t);return this._drawable('curve',[await this.lib.curve(e,i)],i)}async path(e,t){const i=this._options(t),s=[];if(!e)return this._drawable('path',s,i);if(i.fill)if('solid'===i.fillStyle){s.push({type:'path2Dfill',path:e,ops:[]})}else{const t=this.computePathSize(e),n=[[0,0],[t[0],0],[t[0],t[1]],[0,t[1]]],a=await this.lib.patternFillPolygon(n,i);a.type='path2Dpattern',a.size=t,a.path=e,s.push(a)}return s.push((await this.lib.svgPath(e,i))),this._drawable('path',s,i)}}class N extends C{constructor(e,t){super(e,t),this.genAsync=new E(t||null,this.canvas)}get generator(){return this.genAsync}async line(e,t,i,s,n){const a=await this.genAsync.line(e,t,i,s,n);return this.draw(a),a}async rectangle(e,t,i,s,n){const a=await this.genAsync.rectangle(e,t,i,s,n);return this.draw(a),a}async ellipse(e,t,i,s,n){const a=await this.genAsync.ellipse(e,t,i,s,n);return this.draw(a),a}async circle(e,t,i,s){const n=await this.genAsync.circle(e,t,i,s);return this.draw(n),n}async linearPath(e,t){const i=await this.genAsync.linearPath(e,t);return this.draw(i),i}async polygon(e,t){const i=await this.genAsync.polygon(e,t);return this.draw(i),i}async arc(e,t,i,s,n,a,l=!1,o){const p=await this.genAsync.arc(e,t,i,s,n,a,l,o);return this.draw(p),p}async curve(e,t){const i=await this.genAsync.curve(e,t);return this.draw(i),i}async path(e,t){const i=await this.genAsync.path(e,t);return this.draw(i),i}}const W='undefined'!=typeof document;class z{constructor(e,t){this.svg=e,this.gen=new S(t||null,this.svg)}get generator(){return this.gen}static createRenderer(){return new k}get defs(){if(W&&!this._defs){const e=this.svg.ownerDocument||document,t=e.createElementNS('http://www.w3.org/2000/svg','defs');this.svg.firstChild?this.svg.insertBefore(t,this.svg.firstChild):this.svg.appendChild(t),this._defs=t}return this._defs||null}line(e,t,i,s,n){const a=this.gen.line(e,t,i,s,n);return this.draw(a)}rectangle(e,t,i,s,n){const a=this.gen.rectangle(e,t,i,s,n);return this.draw(a)}ellipse(e,t,i,s,n){const a=this.gen.ellipse(e,t,i,s,n);return this.draw(a)}circle(e,t,i,s){const n=this.gen.circle(e,t,i,s);return this.draw(n)}linearPath(e,t){const i=this.gen.linearPath(e,t);return this.draw(i)}polygon(e,t){const i=this.gen.polygon(e,t);return this.draw(i)}arc(e,t,i,s,n,a,l=!1,o){const p=this.gen.arc(e,t,i,s,n,a,l,o);return this.draw(p)}curve(e,t){const i=this.gen.curve(e,t);return this.draw(i)}path(e,t){const i=this.gen.path(e,t);return this.draw(i)}draw(e){const t=e.sets||[],s=e.options||this.gen.defaultOptions,n=this.svg.ownerDocument||W&&document,a=n.createElementNS('http://www.w3.org/2000/svg','g');for(const l of t){let e=null;switch(l.type){case'path':{e=n.createElementNS('http://www.w3.org/2000/svg','path'),e.setAttribute('d',this.opsToPath(l)),e.style.stroke=s.stroke,e.style.strokeWidth=s.strokeWidth+'',e.style.fill='none';break}case'fillPath':{e=n.createElementNS('http://www.w3.org/2000/svg','path'),e.setAttribute('d',this.opsToPath(l)),e.style.stroke='none',e.style.strokeWidth='0',e.style.fill=s.fill;break}case'fillSketch':{e=this.fillSketch(n,l,s);break}case'path2Dfill':{e=n.createElementNS('http://www.w3.org/2000/svg','path'),e.setAttribute('d',l.path||''),e.style.stroke='none',e.style.strokeWidth='0',e.style.fill=s.fill;break}case'path2Dpattern':{const t=l.size,a=n.createElementNS('http://www.w3.org/2000/svg','pattern'),o=`rough-${p(Math.random()*(Number.MAX_SAFE_INTEGER||999999))}`;a.setAttribute('id',o),a.setAttribute('x','0'),a.setAttribute('y','0'),a.setAttribute('width','1'),a.setAttribute('height','1'),a.setAttribute('height','1'),a.setAttribute('viewBox',`0 0 ${i(t[0])} ${i(t[1])}`),a.setAttribute('patternUnits','objectBoundingBox');const r=this.fillSketch(n,l,s);a.appendChild(r),this.defs.appendChild(a),e=n.createElementNS('http://www.w3.org/2000/svg','path'),e.setAttribute('d',l.path||''),e.style.stroke='none',e.style.strokeWidth='0',e.style.fill=`url(#${o})`;break}}e&&a.appendChild(e)}return a}opsToPath(e){return this.gen.opsToPath(e)}fillSketch(e,t,i){let s=i.fillWeight;0>s&&(s=i.strokeWidth/2);const n=e.createElementNS('http://www.w3.org/2000/svg','path');return n.setAttribute('d',this.opsToPath(t)),n.style.stroke=i.fill,n.style.strokeWidth=s+'',n.style.fill='none',n}}class L extends z{constructor(e,t){super(e,t),this.genAsync=new E(t||null,this.svg)}get generator(){return this.genAsync}async line(e,t,i,s,n){const a=await this.genAsync.line(e,t,i,s,n);return this.draw(a)}async rectangle(e,t,i,s,n){const a=await this.genAsync.rectangle(e,t,i,s,n);return this.draw(a)}async ellipse(e,t,i,s,n){const a=await this.genAsync.ellipse(e,t,i,s,n);return this.draw(a)}async circle(e,t,i,s){const n=await this.genAsync.circle(e,t,i,s);return this.draw(n)}async linearPath(e,t){const i=await this.genAsync.linearPath(e,t);return this.draw(i)}async polygon(e,t){const i=await this.genAsync.polygon(e,t);return this.draw(i)}async arc(e,t,i,s,n,a,l=!1,o){const p=await this.genAsync.arc(e,t,i,s,n,a,l,o);return this.draw(p)}async curve(e,t){const i=await this.genAsync.curve(e,t);return this.draw(i)}async path(e,t){const i=await this.genAsync.path(e,t);return this.draw(i)}}var R={canvas(e,t){return t&&t.async?new N(e,t):new C(e,t)},svg(e,t){return t&&t.async?new L(e,t):new z(e,t)},createRenderer(){return C.createRenderer()},generator(e,t){return e&&e.async?new E(e,t):new S(e,t)}};return R});
